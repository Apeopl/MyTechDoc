一、Java技术体系组成部分
	1.Java程序设计语言
	2.各种硬件平台上的Java虚拟机
	3.Class文件格式
	4.Java API类库
	5.来自商业机构和开源社区的Java类库
	注：
		JDK:Java程序设计语言、Java虚拟机、Java API类库，是支持Java程序开发的最小环境。
		JRE:Java API类库中的JavaSE API子集、Java虚拟机，是支持Java程序运行的标准环境。
二、Java与C++之间有一堵由内存动态分配和垃圾回收技术所围成的高墙，墙外边的人想进来，墙里边的人想出去。
三、运行时数据区
	1.方法区
		各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。
		
	2.虚拟机栈
		线程私有，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的
		时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被
		调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
		异常：
			StackOverFlowError:当线程请求的栈深度大于虚拟机所容许的深度
			OutOfMemoryError:当虚拟机栈动态扩展时，无法申请到足够的内存。
	3.本地方法栈
		虚拟机使用到的Native方法服务。
	4.堆
		是Java虚拟机所管理的内存中最大的一块。是所有线程共享的一块区域，虚拟机启动时创建，此内存区域
		的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
	5.程序计数器
		是较小的一块内存空间，他的作用可以看做是当前线程所执行的字节码的行号指示器。
四、垃圾回收
	1.引用计数算法：引用时计数器加1，引用时效时，计数器减1。（虚拟机并不是通过引用计数法来判断对象是否存活）
	2.根搜索算法：基本思路就是通过一系列名为“GC Roots”的对象为起始点，从这些节点开始向下搜索，搜索走过的路径
		成为引用链，当一个对象到“GC Roots”没有任何引用链相连，则证明此对象是不可用的。
	“GC Roots”对象：
		a.虚拟机栈（栈帧中的本地变量表）中引用的对象
		b.方法区中的类静态属性引用的对象
		c.方法区中常量引用的对象
		d.本地方法中JNI引用的对象
	无用的类：
		该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
		加载该类的ClassLoader已经被回收
		该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法
五、垃圾收集算法
	1.标记-清除算法：首先标记处所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象
		缺点：效率问题，标记和清除过程的效率都不高。空间问题，标记清除之后会产生大量不连续的内存碎片
	2.复制算法：将可用内存按照容量划分成大小相同的两块，每次只使用其中一块，当这一块的内存使用完了，就将还存活的
			对象复制到另一块中，然后把已使用过的内存空间一次清理掉。
		缺点：内存缩减为原来的一半
	3.标记-整理算法：标记所有需要回收的对象，让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。
	4.分代收集算法：根据对象存货周期的不同将内存划分为几块，一般分为新生代和老年代，新生代只有少量存活，选用
		复制算法就可以完成收集，老年代因为对象存活率高、没有额外空间对其进行分配担保，就必须使用标记-清除算法
		或者标记-整理算法进行收集。
六、Class文件格式
	1.实现平台和语言无关性的基础是虚拟机和字节码存储格式
七、类加载
	1.类加载机制：虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成
		可以被虚拟机直接使用的Java类型。
	2.类加载时机：加载、连接(验证、准备、解析)、初始化、使用、卸载
		加载：通过类的全限定类名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行
			时数据结构，在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。
		验证：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全。
		准备：正式的为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。仅包括类变量(static修饰)
		解析：虚拟机将常量池中的符号引用替换为直接引用的过程。
			符号引用：以一组符号来描述所引用的目标
			直接引用：直接指向目标的指针、相对偏移量或是能间接定位到目标的句柄。
		初始化：类加载过程中的最后一步，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。
	3.双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类
		去完成，每一个层次的类加载器都是如此，因此所有的加载请求都会传送到顶层的启动类加载器，只有当父类加载器
		反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。
P315
			
			
			
			